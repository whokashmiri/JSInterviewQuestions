Implicit binding in JavaScript refers to how the this keyword is automatically set to the object that is calling a function.


Throttling
Throttling ensures a function is called at most once in a specified period. It’s useful for events that can fire very frequently, like scrolling.

Debouncing
Debouncing ensures a function is called only after a specified period of inactivity. It’s useful for events like typing, where you want to wait until the user has stopped typing before making an API call

function throttle(func, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = new Date().getTime();
    if (now - lastCall < delay) {
      return;
    }
    lastCall = now;
    return func(...args);
  };
}

function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func(...args);
    }, delay);
  };
}


Basic Concepts
==var, let, const?
var: Function-scoped, allows redeclaration and updates.
let: Block-scoped, does not allow redeclaration but can be updated.
const: Block-scoped, neither redeclarable nor updateable.

==JavaScript data types?
Primitive: String, Number, Boolean, Null, Undefined, Symbol, BigInt.
Non-primitive: Objects, including Arrays and Functions.

== vs ===?
==: Compares values only and performs type coercion if necessary.
===: Compares both values and types, ensuring strict equality.

==What is a closure?
A closure is a function that has access to variables from its outer function even after the outer function has finished executing.

==What is this?
this refers to the current execution context. It can refer to:
The global object (window in browsers) in the global scope.
The object that owns the method in object methods.
The surrounding scope in arrow functions.

Intermediate Concepts

==call(), apply(), bind()?
call: Invokes the function immediately with the specified this value and arguments provided individually.
apply: Invokes the function immediately with the specified this value and arguments provided as an array.
bind: Returns a new function with the specified this value and initial arguments, which can be called later.

==Event loop?
The event loop processes tasks from the callback and microtask queues after executing all synchronous code in the call stack.

==undefined vs null?
undefined: A variable is declared but not assigned a value.
null: A variable is explicitly assigned to represent no value.

==Promises?

A Promise is an object representing the eventual completion or failure of an asynchronous operation. It allows you to write asynchronous code in a more manageable way.
States of a Promise:
Pending: Initial state, neither fulfilled nor rejected.
Fulfilled: Operation completed successfully.
Rejected: Operation failed.

Fetch
The fetch function is used to make network requests. It returns a Promise that resolves to the Response object representing the response to the request.

Async/Await
async and await are syntactic sugar built on top of Promises. They make asynchronous code look and behave more like synchronous code, making it easier to read and write.

Promises, fetch, async/await, and then/catch are essential tools for handling asynchronous operations in JavaScript. They help you manage asynchronous code more effectively and make it easier to read and maintain.


==Hoisting?
Variables and function declarations are moved to the top of their scope during compilation. Only declarations are hoisted, not initializations.

Advanced Concepts
==Synchronous vs Asynchronous?
Synchronous: Tasks are executed sequentially, one at a time.
Asynchronous: Tasks can run independently, allowing the program to continue executing without waiting for a task to finish.

==Arrow functions?
Shorter syntax for writing functions. They don’t have their own this, don’t bind arguments, and can’t be used as constructors.

==async and await?
async: Declares a function as asynchronous, returning a promise.
await: Pauses the async function until a promise resolves or rejects, allowing for synchronous-like code.

==map(), forEach(), filter(), reduce()?
map(): Creates a new array by transforming each element.
The map() method is an ES5 feature that creates a new array by applying a function to each element of the original array.
forEach(): Executes a function on each array element, no return value.
filter(): Creates a new array with elements that pass a condition.
The reduce method in JavaScript does not return a new array. Instead, it executes a reducer function on each element of the array, resulting in a single output value
reduce(): Reduces an array to a single value by accumulating results.
The filter() method creates a new array containing elements that satisfy a specified condition. This method skips empty elements and does not change the original array.


Shallow Copy
A shallow copy of an object is a copy of the object's structure, but not the nested objects. It copies the references to the nested objects, not the objects themselves. This means changes to the nested objects in the copied object will affect the original object.

let original = { a: 1, b: { c: 2 } };
let shallowCopy = Object.assign({}, original);

shallowCopy.b.c = 3;
console.log(original.b.c); // Output: 3
Methods to Create Copies
Shallow Copy: Object.assign(), spread operator { ...obj }



Deep Copy
A deep copy, on the other hand, copies the entire structure of the object, including all nested objects. This means changes to the nested objects in the copied object will not affect the original object.

let original = { a: 1, b: { c: 2 } };
let deepCopy = JSON.parse(JSON.stringify(original));
deepCopy.b.c = 3;
console.log(original.b.c); // Output: 2

Deep Copy: JSON.parse(JSON.stringify(obj)), libraries like Lodash's _.cloneDeep()


The slice() method returns a shallow copy of a portion of an array into a new array object. It does not modify the original array. You can specify the start and end indices to define the portion of the array you want to copy.


The splice() method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. It modifies the original array and returns an array containing the deleted elements.